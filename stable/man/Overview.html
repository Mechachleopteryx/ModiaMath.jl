<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · ModiaMath</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ModiaMath</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href="Overview.html">Overview</a><ul class="internal"><li><a class="toctext" href="#Mathematical-Description-1">Mathematical Description</a></li><li><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#Package-structure-1">Package structure</a></li></ul></li><li><a class="toctext" href="Plans.html">Plans for version 1.0</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/SimulationEngine.html">SimulationEngine</a></li><li><a class="toctext" href="../lib/Result.html">Result</a></li><li><a class="toctext" href="../lib/DAE.html">DAE</a></li><li><a class="toctext" href="../lib/NonlinearEquations.html">NonlinearEquations</a></li><li><a class="toctext" href="../lib/Variables.html">Variables</a></li><li><a class="toctext" href="../lib/Logging.html">Logging</a></li><li><a class="toctext" href="../lib/Frames.html">Frames</a></li><li><a class="toctext" href="../lib/Utilities.html">Utilities</a></li><li><a class="toctext" href="../lib/ModiaMath.html">Constants and Types</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="Overview.html">Overview</a></li></ul><a class="edit-page" href="https://github.com/ModiaSim/ModiaMath.jl/blob/master/docs/src/man/Overview.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Overview</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h1><h2><a class="nav-anchor" id="Mathematical-Description-1" href="#Mathematical-Description-1">Mathematical Description</a></h2><p>ModiaMath provides a simulation engine and other mathematical utilities  to solve initial value problems of the following <strong>implicit index 1 DAE with events</strong> (containing an ODE or a semi-explicit index 1 DAE as special cases; <span>$x(t), z(t)$</span> are real vectors):</p><div>\[\begin{align}
     z &amp;= f_z(x, t) \\
 0 = r &amp;= \left[ \begin{array}{l}
                  M_d(x,t,z_i&gt;0) \cdot \dot{x} + b_d(x,t,z_i&gt;0) \;\;\; (= f_d)\\
                  f_c(x,t,z_i&gt;0)
                 \end{array} \right] \\                 
 J &amp;= \left[ \begin{array}{c}
               M_d \\  
               \frac{\partial f_c}{\partial x} 
             \end{array}\right] \;\; \text{is regular (matrix is invertible)}
\end{align}\]</div><p>where</p><div>\[\lim_{\epsilon \rightarrow 0} x(t_0 - \epsilon) = x_0^{-}\]</div><p>is given. Note, that it is assumed that equations <span>$f_d$</span> are linear in the derivatives <span>$\dot{x}$</span>. Equations <span>$z=z(t)$</span> are zero-crossing functions. Whenever a <span>$z_i(t)$</span> crosses zero,  integration is halted, the DAE equations <span>$f_d, f_c$</span> might be changed and afterwards integration is restarted.  At an event instant some <span>$f_c$</span> equations might become <span>$f_d$</span> equations and vice versa. If the Jacobian <span>$J$</span> is <strong>regular</strong>, the DAE has an index 1 (= by differentiating <span>$f_c$</span> once, the system can be transformed to an ODE).</p><p>ModiaMath assumes that <span>$J$</span> is <strong>regular</strong> for all time instants. If this condition is violated, initialization and simulation will usually fail and an error message of the form <em>&quot;Solver does not converge&quot;</em> might appear. Note, ModiaMath does not check this condition and can therefore not provide better diagnostics in such cases.</p><p>Initial conditions <span>$x_{ev}^{-}$</span> must be provided before simulation can start (<span>$x_{ev}^{-} = x_0^{-}$</span>) or at an event restart. They need  <strong>not</strong> to fulfill the constraint equations, so <span>$f_c (x_{ev}^{-},t_{ev} )≠0$</span> is allowed. If this is the case, initialization/re-initialization will simulate for an infinitesimal small time instant  so that <span>$x_{ev}^{-}$</span> changes discontinuously to <span>$x_{ev}^{+}$</span> with <span>$f_c (x_{ev}^{+},t_{ev} )=0$</span>.  This is performed by <em>analytically</em> integrating over the initial time or the event time and might imply to integrate over Dirac impulses (in case <span>$x$</span> is discontinuous at this time instant). Under certain conditions (for details see <a href="#footnote-3">[3]</a>, section 4.2) a numerical approximation of the mathematical (exact) solution is computed, using the new method proposed in <a href="#footnote-3">[3]</a> (equation 8 in section 4.2).</p><p>As shown in <a href="#footnote-1">[1]</a>, <strong>any</strong> DAE can be transformed to the form above with <span>$f_d$</span> nonlinear in <span>$\dot{x}$</span>, at least in principal. In <a href="#footnote-2">[2]</a> algorithms are proposed to automatically transform a large class of DAEs to this form <strong>without solving algebraic equations and retaining the sparsity of the equations</strong>.  This may require to analytically differentiating equations. The algorithms of this paper are implemented in the Julia package <a href="https://github.com/ModiaSim/Modia.jl/">Modia</a> which in turn uses <a href="https://github.com/ModiaSim/ModiaMath.jl/">ModiaMath</a>. In <a href="https://github.com/ModiaSim/Modia3D.jl">Modia3D</a> the transformation to this form is built into the package itself. Since all balance equations in physics and chemistry (such as energy balance, momentum  balance) are linear in the highest derivatives, DAEs describing real world systems are linear in <span>$\dot{x}$</span> and therefore this slight restriction is assumed and utilized by ModiaMath. </p><p>Note, DAE (1)-(3) could be further transformed to an ODE (<span>$\dot{x} = f(x,t)$</span>), but then the evaluation of function <span>$f(x,t)$</span> might require to solve local linear and/or nonlinear equation systems. Furthermore, there are systems  (for example ModiaMath/examples/Simulate_FreeBodyRotation.jl) where the ODE states <span>$x$</span> would then need to be dynamically changed during simulation.</p><p>It is highly recommended to use <a href="https://github.com/ModiaSim/Modia.jl/">Modia</a> or  <a href="https://github.com/ModiaSim/Modia3D.jl">Modia3D</a> for simulating DAEs because this is much simpler and less error prone as when utilizing ModiaMath directly. However, ModiaMath can be also used without Modia or Modia3D. In this case, basically one Julia function with the following interface has to be provided (and in this function specific utility functions can be called)</p><pre><code class="language-julia">getModelResidues(m::AbstractSimulationModel, t::Float64, x::Vector{Float64},  
                 der_x::Vector{Float64}, r::Vector{Float64}</code></pre><p>where <code>r</code> is the vector of residues (<span>$r = \left[ f_d; f_c \right]$</span>). Given the  simulation model <code>m</code> (= a mutable struct), the actual time instant <code>t</code>, the DAE variables <code>x(t)</code> and their derivatives <code>der_x(t)</code>, the function has to compute the residue vector <code>r(t)</code>. In directory ModiaMath/examples/withoutMacros_withoutVariables several examples are present that are based on this interface.</p><p>In order to simplify the definition of direct ModiaMath models (to evaluate and test ModiaMath  functionality), the macro <a href="../lib/Variables.html#ModiaMath.Variables.@component-Tuple{Any,Any}"><code>@component</code></a> has been introduced. The examples in directory ModiaMath/examples/xxx.jl use this model definition. In directory ModiaMath/examples/withoutMacros/xxx.jl the same examples are present, however, the macro has been manually expanded (to show and test the result of the macro). The <a href="../lib/Variables.html#ModiaMath.Variables.@component-Tuple{Any,Any}"><code>@component</code></a> does not yet support events. If events are present in a model, the model has to be defined as shown in the examples of directory ModiaMath/examples/withoutMacros_withoutVariables.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>K.E. Brenan, S.L. Campbell, and L.R. Petzold (1996):   <a href="http://bookstore.siam.org/cl14/">Numerical Solution of Initial Value Problems in   Differential-Algebraic Equations</a>. SIAM.</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>M. Otter, H. Elmqvist (2017): <a href="http://www.ep.liu.se/ecp/132/064/ecp17132565.pdf">Transformation of Differential Algebraic Array Equations   to Index One Form</a>.    12th International Modelica Conference. </p></div><div class="footnote" id="footnote-3"><a href="#footnote-3"><strong>[3]</strong></a><p>A. Benveniste, B. Caillaud, H. Elmqvist, J. Ghorbal, M. Otter, M. Pouzet (2019):   <em>Multi-Mode DAE Models - Challenges, Theory and Implementation</em>.   Computing and Software Science,    <a href="https://www.springer.com/us/book/9783319919072">LNCS 10000</a>,    Editors: B. Steffen and G. Woeginger, Springer.</p></div><h2><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h2><p>You can just past the following code fragments into the Julia REPL.</p><h3><a class="nav-anchor" id="To-define-a-model-1" href="#To-define-a-model-1">To define a model</a></h3><p>(note, it is simpler and less error prone to define a model with Modia or Modia3D):</p><pre><code class="language-julia">  using ModiaMath
  using StaticArrays

  @component Pendulum(;L=1.0, m=1.0, d=0.1, g=9.81) begin
     phi = RealScalar(start=pi/2, unit=&quot;rad&quot;    , fixed=true,               numericType=ModiaMath.XD_EXP)
     w   = RealScalar(start=0.0 , unit=&quot;rad/s&quot;  , fixed=true, integral=phi, numericType=ModiaMath.XD_EXP)
     a   = RealScalar(            unit=&quot;rad/s^2&quot;,             integral=w  , numericType=ModiaMath.DER_XD_EXP) 
     r   = RealSVector{2}(        unit=&quot;m&quot;      ,                           numericType=ModiaMath.WC)
  end;

  function ModiaMath.computeVariables!(p::Pendulum, sim::ModiaMath.SimulationState)  
     L = p.L; m = p.m; d = p.d; g = p.g; phi = p.phi.value; w = p.w.value
   
     p.a.value = (-m*g*L*sin(phi) - d*w) / (m*L^2)

     if ModiaMath.isStoreResult(sim)
        p.r.value = @SVector [L*sin(phi), -L*cos(phi)]
     end
  end;

  simulationModel = ModiaMath.SimulationModel(Pendulum(L=0.8, m=0.5, d=0.2), stopTime=5.0);
   </code></pre><h3><a class="nav-anchor" id="To-simulate-a-model-and-plot-results:-1" href="#To-simulate-a-model-and-plot-results:-1">To simulate a model and plot results:</a></h3><pre><code class="language-julia">  result = ModiaMath.simulate!(simulationModel; log=true);
  ModiaMath.plot(result, [(:phi, :w) :a])</code></pre><p>This results in:</p><img src="../../resources/images/pendulumPlot.svg"><h3><a class="nav-anchor" id="To-run-examples-and-tests:-1" href="#To-run-examples-and-tests:-1">To run examples and tests:</a></h3><pre><code class="language-julia"># run examples
import ModiaMath
include(&quot;$(ModiaMath.path)/examples/Simulate_Pendulum.jl&quot;)         # ODE as index-0 DAE
include(&quot;$(ModiaMath.path)/examples/Simulate_FreeBodyRotation.jl&quot;) # index-1 DAE
include(&quot;$(ModiaMath.path)/examples/withoutMacros_withoutVariables/Simulate_PendulumDAE.jl&quot;) # index-3 DAE
include(&quot;$(ModiaMath.path)/examples/withoutMacros_withoutVariables/Simulate_SimpleStateEvents.jl&quot;)
include(&quot;$(ModiaMath.path)/examples/withoutMacros_withoutVariables/Simulate_BouncingBall.jl&quot;)

# run all tests
include(&quot;$(ModiaMath.path)/test/runtests.jl&quot;)
  </code></pre><h3><a class="nav-anchor" id="To-run-a-multi-mode-example-that-has-Dirac-impulses-1" href="#To-run-a-multi-mode-example-that-has-Dirac-impulses-1">To run a multi-mode example that has Dirac impulses</a></h3><p>The following model from <a href="#footnote-3">[3]</a></p><img src="../../resources/images/idealClutchDiagram.png"><p>is defined by an ideal clutch described by two modes: <em>Released</em> (the clutch shafts rotate freely) and <em>Engaged</em> (the clutch shafts are rigidly fixed). If variable <code>engaged = true</code>, the clutch is in mode <em>Engaged</em> and otherwise in mode <em>Released</em>. An event occurs when Boolean variable <code>engaged</code> changes its value. If the clutch is in mode <em>Released</em> and changes to <em>Engaged</em> a Dirac impulse occurs (the clutch torque becomes infinite) and changes the clutch shaft speeds  (<code>inertia1.w, inertia2.w</code>) in such a way that they coincide. Since <code>inertia1.w</code> is algebraically  coupled to <code>capacitor.v</code> (the voltage over the capacitor) via the <code>emf</code> element, also   <code>capacitor.v</code> changes discontinuously and <code>der(capacitor.v)</code> is a Dirac impulse.  Mathematically, this means that the DAE index is changing depending on the clutch state  and an  <span>$f_c$</span> equation is changed to an <span>$f_d$</span> equation and vice versa. </p><p>This model can be simulated and the result plotted with command:</p><pre><code class="language-julia">import ModiaMath
include(&quot;$(ModiaMath.path)/examples/withoutMacros_withoutVariables/Simulate_IdealClutch.jl&quot;)
  </code></pre><img src="../../resources/images/idealClutchPlot.svg"><p>The results of the simulation are shown in the figure above. The initial speed of inertia1 is w1 = 0 rad/s and w2 = 10 rad/s for inertia2. The capacitor is initially uncharged. The upper two partly overlapping curves are the angular velocities of inertia1 and inertia2. When the clutch is disengaged, the angular velocity of inertia2 is constant. The green curve shows the voltage over the capacitor. Since the clutch is engaged at initialization, Dirac impulses occur at time = 0 s. As a result, after initialization the angular velocities of the two inertias are identical. The common angular velocity at time = 0 s is 6.4 rad/s. The reason is that the capacitor acts in the same way as an additional moment of inertia to inertia1. The effective inertia is </p><div>\[J_{eff} = J1 + J2 + k^2 C = 0.1 + 0.4 + 0.25^2 \cdot 2 = 0.625\]</div><p>Thus, the common angular velocity for the two inertias at time=0 s becomes </p><div>\[\begin{align}
w^{+}_0 &amp;= (J1 \cdot w1^{-}_0 + J2 \cdot w2^{-}_0 + k \cdot C \cdot v^{-}_0)/J_{eff} \\
        &amp;= (0.1\cdot0 + 0.4\cdot10 + 0.25\cdot2\cdot0)/0.625 = 6.4 \text{ rad/s.}
\end{align}\]</div><p>There are no Dirac impulses at time = 100 s when the clutch disengages, but again Dirac impulses at time = 300 s when the clutch engages again.</p><h2><a class="nav-anchor" id="Package-structure-1" href="#Package-structure-1">Package structure</a></h2><p>The ModiaMath package is structured in the a set of sub-modules. The most important ones are:</p><ul><li><a href="../lib/SimulationEngine.html#ModiaMath.SimulationEngine"><code>ModiaMath.SimulationEngine</code></a><br/>The engine to simulate implicit index 1 DAEs with events.</li></ul><ul><li><a href="../lib/DAE.html#ModiaMath.DAE"><code>ModiaMath.DAE</code></a><br/>Interface between the SimulationEngine and the index 1 DAE model (e.g. initialization and event iteration is performed here).</li></ul><ul><li><a href="../lib/Result.html#ModiaMath.Result"><code>ModiaMath.Result</code></a><br/>The <code>plot</code> function of this module allows to plot the result data of the simulation engine by giving the signal names. With tuples and/or vectors/matrices of signal names, the window layout of the figures is defined. The legends/labels of the plots are automatically constructed by the signal names and their units.</li></ul><ul><li><a href="../lib/Variables.html#ModiaMath.Variables"><code>ModiaMath.Variables</code></a><br/>Provides Variable types to define properties of the variables on a higher level and copy automatically the interface vectors from the integrator into the variables and vice versa.</li></ul><ul><li><a href="../lib/Frames.html#ModiaMath.Frames"><code>ModiaMath.Frames</code></a><br/>Functions that generate and operate on frames, that is coordinate systems in 3D. The orientation of a frame is described either with a 3x3 rotation matrix or with a  quaternion vector. This module is currently mainly used from Modia3D, but the functionality is useful for all 3D programs.</li></ul><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="Plans.html"><span class="direction">Next</span><span class="title">Plans for version 1.0</span></a></footer></article></body></html>
