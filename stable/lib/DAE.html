<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DAE · ModiaMath</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ModiaMath</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/Overview.html">Overview</a></li><li><a class="toctext" href="../man/Plans.html">Plans for version 1.0</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="SimulationEngine.html">SimulationEngine</a></li><li><a class="toctext" href="Result.html">Result</a></li><li class="current"><a class="toctext" href="DAE.html">DAE</a><ul class="internal"></ul></li><li><a class="toctext" href="NonlinearEquations.html">NonlinearEquations</a></li><li><a class="toctext" href="Variables.html">Variables</a></li><li><a class="toctext" href="Logging.html">Logging</a></li><li><a class="toctext" href="Frames.html">Frames</a></li><li><a class="toctext" href="Utilities.html">Utilities</a></li><li><a class="toctext" href="ModiaMath.html">Constants and Types</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="DAE.html">DAE</a></li></ul><a class="edit-page" href="https://github.com/ModiaSim/ModiaMath.jl/blob/master/docs/src/lib/DAE.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DAE</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DAE-1" href="#DAE-1">DAE</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE" href="#ModiaMath.DAE"><code>ModiaMath.DAE</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-none">module ModiaMath.DAE</code></pre><p>Interface between the <a href="SimulationEngine.html#ModiaMath.SimulationEngine"><code>ModiaMath.SimulationEngine</code></a> and the index 1 DAE model. A DAE model is a <code>struct</code> that has a required field  <code>simulationState::</code><a href="DAE.html#ModiaMath.DAE.SimulationState"><code>ModiaMath.SimulationState</code></a> in which the main properties of the DAE model are reported to the simulation engine:</p><pre><code class="language-julia"># DAE model ModelName
mutable struct ModelName &lt;: ModiaMath.AbstractSimulationModel
    simulationState::ModiaMath.SimulationState

    # other definitions (e.g. parameters of model)
end</code></pre><p>The following functions can be called in the DAE model to inquire <strong>information about the simulation state</strong>:</p><ul><li><a href="DAE.html#ModiaMath.DAE.getTime-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.getTime</code></a></li><li><a href="DAE.html#ModiaMath.DAE.getStartTime-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.getStartTime</code></a></li><li><a href="DAE.html#ModiaMath.DAE.getStopTime-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.getStopTime</code></a></li><li><a href="DAE.html#ModiaMath.DAE.getTolerance-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.getTolerance</code></a></li><li><a href="DAE.html#ModiaMath.DAE.get_is_constraint-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.get_is_constraint</code></a></li><li><a href="DAE.html#ModiaMath.DAE.compute_der_fc-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.compute_der_fc</code></a></li><li><a href="DAE.html#ModiaMath.DAE.isInitial-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.isInitial</code></a></li><li><a href="DAE.html#ModiaMath.DAE.isTerminal-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.isTerminal</code></a></li><li><a href="DAE.html#ModiaMath.DAE.isEvent-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.isEvent</code></a></li><li><a href="DAE.html#ModiaMath.DAE.isZeroCrossing-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.isZeroCrossing</code></a></li><li><a href="DAE.html#ModiaMath.DAE.isAfterSimulationStart-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.isAfterSimulationStart</code></a></li><li><a href="DAE.html#ModiaMath.DAE.isStoreResult-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.isStoreResult</code></a></li><li><a href="Logging.html#ModiaMath.Logging.isLogInfos-Tuple{ModiaMath.Logging.Logger}"><code>ModiaMath.isLogInfos</code></a></li><li><a href="Logging.html#ModiaMath.Logging.isLogWarnings-Tuple{ModiaMath.Logging.Logger}"><code>ModiaMath.isLogWarnings</code></a></li><li><a href="Logging.html#ModiaMath.Logging.isLogEvents-Tuple{ModiaMath.Logging.Logger}"><code>ModiaMath.isLogEvents</code></a></li></ul><p>The following functions can be called in the DAE model to set <strong>properties in the simulation engine</strong>:</p><ul><li><a href="DAE.html#ModiaMath.DAE.setNominal!-Tuple{ModiaMath.DAE.SimulationState,Array{Float64,1}}"><code>ModiaMath.setNominal!</code></a></li><li><a href="DAE.html#ModiaMath.DAE.setNextEvent!-Tuple{ModiaMath.DAE.SimulationState,Float64}"><code>ModiaMath.setNextEvent!</code></a></li><li><a href="DAE.html#ModiaMath.DAE.positive!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}"><code>ModiaMath.positive!</code></a></li><li><a href="DAE.html#ModiaMath.DAE.negative!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}"><code>ModiaMath.negative!</code></a></li><li><a href="DAE.html#ModiaMath.DAE.change!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}"><code>ModiaMath.change!</code></a></li><li><a href="DAE.html#ModiaMath.DAE.edge!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}"><code>ModiaMath.edge!</code></a></li></ul><p>The following functions can be either called in the DAE model or they can be called on a simulation model (before or after <code>ModiaMath.simulate!(simulationModel, ...)</code> is called).</p><ul><li><a href="Logging.html#ModiaMath.Logging.logOn!-Tuple{ModiaMath.Logging.Logger}"><code>ModiaMath.logOn!</code></a></li><li><a href="Logging.html#ModiaMath.Logging.logOff!-Tuple{ModiaMath.Logging.Logger}"><code>ModiaMath.logOff!</code></a></li><li><a href="Logging.html#ModiaMath.Logging.setLogCategories!-Tuple{ModiaMath.Logging.Logger,Array{Symbol,1}}"><code>ModiaMath.setLogCategories!</code></a></li></ul><p><strong>Main developer</strong></p><p><a href="https://rmc.dlr.de/sr/de/staff/martin.otter/">Martin Otter</a>,  <a href="https://www.dlr.de/sr/en">DLR - Institute of System Dynamics and Control</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/_module.jl#L4-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.EventRestart" href="#ModiaMath.DAE.EventRestart"><code>ModiaMath.DAE.EventRestart</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">@enum EventRestart NoRestart Restart FullRestart Terminate</code></pre><p>Define how to continue or restart integration after an event. Usually, <code>Restart</code> should be used. Only in special cases, the other flags are useful.</p><ul><li><code>NoRestart</code>, continue integration without restarting the integrator</li><li><code>Restart</code>, restart integrator</li><li><code>FullRestart</code>, restart integrator and optionally exchange simulationState (so dimensions may change)</li><li><code>Terminate</code>, terminate integration</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.SimulationState" href="#ModiaMath.DAE.SimulationState"><code>ModiaMath.DAE.SimulationState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">simulationState = SimulationState(name, getModelResidues!, x_start, 
                                  getVariableName; kwargs...)</code></pre><p>Return a <code>simulationState</code> object that is described by a DAE with one of the supported structures defined with enumeration <a href="DAE.html#ModiaMath.DAE.StructureOfDAE"><code>StructureOfDAE</code></a>.</p><p>A <code>model</code> that shall be simulated with function <a href="SimulationEngine.html#ModiaMath.SimulationEngine.simulate!-Tuple{ModiaMath.AbstractSimulationModel}"><code>ModiaMath.simulate!</code></a><code>(model, ...)</code> is required to be defined as:</p><pre><code class="language-julia">mutable struct ModelName &lt;: ModiaMath.AbstractSimulationModel
    simulationState::ModiaMath.SimulationState

    # other definitions (e.g. parameters of model)
end</code></pre><table><tr><th>Keyword arguments</th><th>defaults</th></tr><tr><td>structureOfDAE</td><td>DAE_LinearDerivativesAndConstraints (see <a href="DAE.html#ModiaMath.DAE.StructureOfDAE"><code>StructureOfDAE</code></a>)</td></tr><tr><td>is_constraint</td><td>fill(false, length(x_start))</td></tr><tr><td>has_constraintDerivatives</td><td>false</td></tr><tr><td>nz</td><td>0</td></tr><tr><td>nw</td><td>0</td></tr><tr><td>zDir</td><td>fill(0, nz)</td></tr><tr><td>x_fixed</td><td>fill(false, length(x_start))</td></tr><tr><td>x_nominal</td><td>fill(NaN, length(x_start))</td></tr><tr><td>x_errorControl</td><td>fill(true, length(x_start))</td></tr><tr><td>jac</td><td>nothing (not yet supported)</td></tr><tr><td>maxSparsity</td><td>0.1</td></tr><tr><td>hev</td><td>1e-8  (only for DAE_NoSpecialStructure)</td></tr><tr><td>scaleConstraintsAtEvents</td><td>true  (not used; only for backwards compatibility)</td></tr><tr><td>nc</td><td>0 (not used; only for backwards compatibility)</td></tr><tr><td>getResultNames</td><td><a href="DAE.html#ModiaMath.DAE.getResultNames-Tuple{Any}"><code>ModiaMath.getResultNames</code></a></td></tr><tr><td>storeResult!</td><td><a href="Result.html#ModiaMath.Result.storeRawResult!-Tuple{ModiaMath.Result.RawResult,Array{Float64,1}}"><code>ModiaMath.storeRawResult!</code></a></td></tr><tr><td>getResult</td><td><a href="Result.html#ModiaMath.Result.getStringDictResult-Tuple{Any,ModiaMath.Result.RawResult}"><code>ModiaMath.getStringDictResult</code></a></td></tr><tr><td>defaultTolerance</td><td>1e-4</td></tr><tr><td>defaultStartTime</td><td>0.0</td></tr><tr><td>defaultStopTime</td><td>1.0</td></tr><tr><td>defaultInterval</td><td>NaN</td></tr></table><p><strong>Required arguments</strong></p><ul><li><p><code>name::Union{AbstractString,Symbol}</code>: Name of model</p></li><li><p><code>getModelResidues!::Function</code>: Function with arguments <code>(model,t,x,derx,r,w)</code> to compute the residues <code>r</code> and auxiliary variables <code>w</code> from time <code>t</code>, vector <code>x</code> and its time derivative <code>derx</code>. </p></li></ul><ul><li><p><code>x_start::Vector{Float64}</code>: Start values of <code>x</code>.</p></li><li><p><code>getVariableName::Function=</code><a href="DAE.html#ModiaMath.DAE.defaultVariableName-Tuple{Any,ModiaMath.DAE.VariableCategory,Int64}"><code>ModiaMath.defaultVariableName</code></a>: Function that returns the name of a variable, given its type and its index.</p></li></ul><p><strong>Optional (keyword) arguments:</strong></p><ul><li><p><code>structureOfDAE::</code><a href="DAE.html#ModiaMath.DAE.StructureOfDAE"><code>StructureOfDAE</code></a>: Structure of DAE.</p></li><li><p><code>is_constraint::Vector{Bool}</code>: = true, <code>residue[i]</code> is a constraint equation <code>fc</code> or its derivative.                                = false, <code>residue[i]</code> is not a constraint equation.                                (is only used for <code>structureOfDAE = DAE_LinearDerivativesAndConstraints</code>)</p></li><li><p><code>has_constraintDerivatives::Vector{Bool}</code>: if <a href="DAE.html#ModiaMath.DAE.compute_der_fc-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.compute_der_fc</code></a> returns true                       and <code>is_constraint[i] = true</code>:                        = true , <code>residue[i]</code> is the derivative of an <code>fc</code> equation                        = false, <code>residue[i]</code> is an <code>fc</code> equation                       (is only used for <code>structureOfDAE = DAE_LinearDerivativesAndConstraints</code>)</p></li><li><p><code>nz::Int</code>: Number of event indicators</p></li><li><p><code>nw::Int</code>: Number of auxiliary variables (Float64 variables that are additionally computed            and stored at communication points, and where start values can be provided            for initialization)</p></li><li><p><code>zDir::Vector{Int}</code>: Interpretation of event indictors:  zDir[i] = 0: Root is reported for both crossing directions,          = 1: Root is reported when crossing from negative to positive direction          = -1: Root is reported when crossing from positive to negative direction</p></li><li><p><code>x_fixed::Vector{Bool}</code>: = true, <code>x_start[i]</code> is fixed during initialization. = false, <code>x_start[i]</code> might be changed, e.g., due to an initial impulse.</p></li><li><p><code>x_nominal::Vector{Float64}</code>: Nominal values of <code>x</code>. if <code>x_nominal[i]=NaN</code> no nominal value is defined for <code>x[i]</code> and a nominal value is computed (<code>x_nominal[i] = abs(x_start[i]) &gt; 1e-7 ? abs(x_start[i]) : 1.0</code>).</p></li><li><p><code>x_errorControl::Vector{Bool}</code>: = true, the absolute error tolerance is set to <code>0.1 * relativeTolerance * x_nominal[i]</code>. = false, the absolute error tolerance is switched off (is set to a large value). This is recommended for variables that are basically not limited (for example the angle of a shaft that is permantently rotating in the same direction and therefore becomes larger and larger).</p></li><li><p><code>hev::Float64</code>: Stepsize used during initialization and at event restart if <code>structureOfDAE = ModiaMath.DAE_NoSpecialStructure</code>. Otherwise <code>hev</code> is ignored.</p></li><li><p><code>scaleConstraintsAtEvents::Bool</code>: Dummy argument. Only kept for backwards compatibility.</p></li><li><p><code>nc::Int</code>: Dummy argument. Only kept for backwards compatibility.</p></li><li><p><code>jac</code>: Sparse Jacobian datastructure (currently not supported).</p></li><li><p><code>maxSparsity::Float64</code>: A sparse Jacobian is only used during simulation if sparseness of jac &lt; maxSparsity (currently not supported)</p></li><li><p><code>getResultNames::Function</code>: Function that returns the names of the variables to be stored in the result data structure.</p></li><li><p><code>storeResult!::Function</code>: Function that stores the raw results.</p></li><li><p><code>getResult::Function</code>: Function that resturns the result data structure after the simulation.</p></li><li><p><code>defaultTolerance::Float64</code>: Model specific default relative tolerance, if not redefined in the call to <a href="SimulationEngine.html#ModiaMath.SimulationEngine.simulate!-Tuple{ModiaMath.AbstractSimulationModel}"><code>ModiaMath.simulate!</code></a>.</p></li><li><p><code>defaultStartTime::Float64</code>: Model specific default start time in [s], if not redefined in the call to <a href="SimulationEngine.html#ModiaMath.SimulationEngine.simulate!-Tuple{ModiaMath.AbstractSimulationModel}"><code>ModiaMath.simulate!</code></a>.</p></li><li><p><code>defaultStopTime::Float64</code>: Model specific default stop time in [s], if not redefined in the call to <a href="SimulationEngine.html#ModiaMath.SimulationEngine.simulate!-Tuple{ModiaMath.AbstractSimulationModel}"><code>ModiaMath.simulate!</code></a>.</p></li><li><p><code>defaultInterval::Float64</code>: Model specific default interval in [s], if not redefined in the call to <a href="SimulationEngine.html#ModiaMath.SimulationEngine.simulate!-Tuple{ModiaMath.AbstractSimulationModel}"><code>ModiaMath.simulate!</code></a>. Result data is stored every <code>defaultInterval</code> seconds. If <code>defaultInterval=NaN</code>, the default interval is computed as <code>interval = (stopTime - startTime)/500.0</code>. </p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/simulationState.jl#L186-L314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.StructureOfDAE" href="#ModiaMath.DAE.StructureOfDAE"><code>ModiaMath.DAE.StructureOfDAE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">@enum StructureOfDAE
      DAE_LinearDerivativesAndConstraints
      DAE_ExplicitDerivatives 
      DAE_NoSpecialStructure</code></pre><p>Enumeration defining the structure of the DAE of the simulation model.  The following DAE structures are supported  (function <code>getModelResidues!(model, t, x, derx, r, w; simulation=true)</code> returns the residues <code>r</code>):</p><p><strong>ModiaMath.DAE_LinearDerivativesAndConstraints (default)</strong></p><div>\[\begin{align}
     z &amp;= f_z(x,t) \\
 0 = r &amp;= \left[ \begin{array}{l}
                    M_d(x,t,z_i&gt;0) \cdot \dot{x} + b_d(x,t,z_i&gt;0) \;\; (= f_d) \\
                    f_c(x,t,z_i&gt;0)
                  \end{array} \right] \\
     J &amp;= \left[ M_d;  
                  \frac{\partial f_c}{\partial x} \right] \; \text{is regular (matrix is invertible)}
\end{align}\]</div><p>where</p><div>\[\lim_{\epsilon \rightarrow 0} x(t_0 - \epsilon) = x_0^{-}\]</div><p>Equations <span>$f_d$</span> are linear in the derivatives <span>$\dot{x}$</span>. It is required that the Jacobian <span>$J$</span> is <strong>regular</strong>, that is the DAE has an index 1 (= by differentiating <span>$f_c$</span> once, the system can be transformed to an ODE).</p><p>Equations <span>$z=z(t)$</span> are zero-crossing functions. Whenever a <span>$z_i(t)$</span> crosses zero,  an event is triggered and simulation is halted. During an event, <span>$z_i &gt; 0$</span> can change its value. The equations above are solved with a fixed-point iteration scheme (= <em>event iteration</em>) until <span>$z_i &gt; 0$</span> does not change anymore. Afterwards, integration is  restarted and the Boolean variable <span>$z_{pos} = z_{i,ev} &gt; 0$</span> keeps its value until  the next event occurs.</p><p>At an event instant some <span>$f_c$</span> equations might become <span>$f_d$</span> equations and vice versa. The constraint equations <span>$f_c$</span> can be at any position of the residue vector <code>r</code> and at an event instant <span>$f_c$</span> equations might become <span>$f_d$</span> equations and vice versa. When instantiating a <a href="DAE.html#ModiaMath.DAE.SimulationState"><code>SimulationState</code></a>, the initial definition of the constraint equations is provided with vector argument <code>is_constraint</code>. Note, it is also possible to define time events, so triggering events at pre-defined time instants, for example to model sampled data systems  (see <a href="DAE.html#ModiaMath.DAE.setNextEvent!-Tuple{ModiaMath.DAE.SimulationState,Float64}"><code>ModiaMath.setNextEvent!</code></a>).</p><p>Initial conditions <span>$x_{ev}^{-}$</span> must be provided before simulation can start (<span>$x_{ev}^{-} = x_0^{-}$</span>) or at an event restart. They need  <strong>not</strong> to fulfill the constraint equations, so <span>$f_c (x_{ev}^{-},t_{ev} ) \neq 0$</span> is allowed. If this is the case, initialization/re-initialization will simulate for an infinitesimal small time instant  so that <span>$x_{ev}^{-}$</span> changes discontinuously to <span>$x_{ev}^{+}$</span> with <span>$f_c (x_{ev}^{+},t_{ev} )=0$</span>.  This is performed by <em>analytically</em> integrating over the initial time or the event time and might imply to integrate over Dirac impulses (in case <span>$x$</span> is discontinuous at this time instant). Under certain conditions a numerical approximation of the mathematical (exact) solution is computed.</p><p>The derivative of the constraint equations <span>$f_c$</span> can be provided at event restart. In this case <span>$\frac{\partial f_c}{\partial x}$</span> is computed with the provided <span>$\dot{f}_c$</span>, instead of computing it with finite differences (which is numerically less reliable). In both cases <span>$\dot{x}_{ev}^{+}$</span> is then computed by solving a linear equation system with Jacobian <span>$J$</span>.</p><p><strong>ModiaMath.DAE_ExplicitDerivatives</strong></p><div>\[\begin{align}
     z &amp;= f_z(x, t) \\
 0 = r &amp;= - \dot{x} + b_d(x,t,z_i&gt;0) \;\; (= f_d)
\end{align}\]</div><p>where</p><div>\[x(t_0) = x_0\]</div><p>This is a special case of the first form, where no constraint equations are present and the derivatives are explicit. This form is also called ODE (Ordinary Differential Equations in state space form). It has the advantage that many ODE integration methods can be used to solve this system.</p><p>Initialization and re-initialization is trivial, because <span>$x_{ev}^{+}$</span> is provided as initial value or at event restart from the model and then:</p><div>\[der(x_{ev})^{+} := f_d(0, x_{ev}^{+}, t_{ev})\]</div><p>Note, if a Dirac impulse occurs in the model, then this property has to be handled inside the model and the result of analytically integrating over the event instant must be returned as <span>$x_{ev}^{+}$</span> from the model.</p><p><strong>ModiaMath.DAE_NoSpecialStructure</strong></p><div>\[\begin{align}
     z &amp;= f_z(x,t) \\
 0 = r &amp;= f(\dot{x},x,t,z_i&gt;0)
 \end{align}\]</div><p>This is a general DAE. Initialization and re-initialization is performed by using an implicit Euler step. When appropriately scaling <code>r</code>, using a step size that tends to zero and under further assumptions, then this solution can be interpreted as analytically integrating over the time instant. This might mean to integrate over Dirac impulses (in case <code>x</code> is discontinuous at this time instant). Since the selected step size is not close to zero, the implicit Euler step will give a very rough approximation of the analytical integral. A much better approximation is achieved with option  <code>DAE_LinearDerivativesAndConstraints</code> above where a step size of zero is used.</p><p>This structure is only provided for backwards compatibility. It is numerically not reliable and should no longer be used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.change!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}" href="#ModiaMath.DAE.change!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}"><code>ModiaMath.DAE.change!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.change!(sim, nr, crossing, crossingAsString; restart = ModiaMath.Restart)</code></pre><p>Trigger an event, whenever <code>crossing &gt; 0</code> changes from <code>false</code> to <code>true</code> or from <code>true</code> to <code>false</code>. The function returns always <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L230-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.compute_der_fc-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.compute_der_fc-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.compute_der_fc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.compute_der_fc(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>If true is returned, return the derivative of the constraint equation in residues <code>r[i]</code>.  Otherwise return constraint equations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L57-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.defaultVariableName-Tuple{Any,ModiaMath.DAE.VariableCategory,Int64}" href="#ModiaMath.DAE.defaultVariableName-Tuple{Any,ModiaMath.DAE.VariableCategory,Int64}"><code>ModiaMath.DAE.defaultVariableName</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">defaultVariableName(model, vcat, vindex)</code></pre><p>Return default names for the variables (e.g. <code>x[1]</code>)</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/simulationState.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.edge!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}" href="#ModiaMath.DAE.edge!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}"><code>ModiaMath.DAE.edge!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.edge!(sim, nr, crossing, crossingAsString; restart = ModiaMath.Restart)</code></pre><p>Trigger an event, whenever <code>crossing &gt; 0</code> switches from <code>false</code> to <code>true</code>. The function returns always <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L240-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.getResultNames-Tuple{Any}" href="#ModiaMath.DAE.getResultNames-Tuple{Any}"><code>ModiaMath.DAE.getResultNames</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>getResultNames(model)</p><p>Return a vector of result names.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/simulationState.jl#L48-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.getStartTime-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.getStartTime-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.getStartTime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.getStartTime(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return <strong>startTime</strong> of the actual simulation run.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L20-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.getStopTime-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.getStopTime-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.getStopTime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.getStopTime(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return <strong>stopTime</strong> of the actual simulation run (when the simulation will be terminated).</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L29-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.getTime-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.getTime-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.getTime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.getTime(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return actual <strong>simulation time</strong>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L10-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.getTolerance-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.getTolerance-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.getTolerance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.getTolerance(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return (relative) <strong>tolerance</strong> of the actual simulation run.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L38-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.getVariableName" href="#ModiaMath.DAE.getVariableName"><code>ModiaMath.DAE.getVariableName</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">getVariableName(model, vcat, vindex, nx=0; 
                xNames   =nameVector(&quot;x&quot;, nx),
                derxNames=fcNameVector(&quot;der&quot;, xNames),
                wNames   =String[])</code></pre><p>Given category <code>vcat</code> and index <code>vindex</code>of category,  return the full path name of the respective variable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/simulationState.jl#L24-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.get_is_constraint-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.get_is_constraint-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.get_is_constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.get_is_constraint(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return reference to <code>is_constraint</code> vector (this vector can be modified in <code>getModelResidues!</code> if <a href="DAE.html#ModiaMath.DAE.isEvent-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.isEvent</code></a> returns true.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L47-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.isAfterSimulationStart-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.isAfterSimulationStart-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.isAfterSimulationStart</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.isAfterSimulationStart(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return true, if after start of simulation and false if during initialization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L107-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.isEvent-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.isEvent-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.isEvent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.isEvent(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return true, if <strong>event phase</strong> of simulation (including initialization)</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L87-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.isInitial-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.isInitial-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.isInitial</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.isInitial(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return true, if <strong>initialization phase</strong> of simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L67-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.isStoreResult-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.isStoreResult-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.isStoreResult</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.isStoreResult(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return true, if <strong>communication point</strong> and variables shall be stored in the result data structure.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L117-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.isTerminal-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.isTerminal-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.isTerminal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.isTerminal(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return true, if <strong>terminal phase</strong> of simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L77-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.isZeroCrossing-Tuple{ModiaMath.DAE.SimulationState}" href="#ModiaMath.DAE.isZeroCrossing-Tuple{ModiaMath.DAE.SimulationState}"><code>ModiaMath.DAE.isZeroCrossing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.isZeroCrossing(m::ModiaMath.[AbstractSimulationModel|SimulationState])</code></pre><p>Return true, if simulation model shall compute zero-crossing functions (as required by the integrator).</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L97-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.negative!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}" href="#ModiaMath.DAE.negative!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}"><code>ModiaMath.DAE.negative!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.negative!(sim, nr, crossing, crossingAsString; restart = ModiaMath.Restart)</code></pre><p>Return <code>crossing &lt; 0</code> such that a state event is triggered whenever <code>crossing &lt; 0</code> changes its value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L220-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.positive!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}" href="#ModiaMath.DAE.positive!-Tuple{ModiaMath.DAE.SimulationState,Int64,Float64,String}"><code>ModiaMath.DAE.positive!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.positive!(sim, nr, crossing, crossingAsString; restart = ModiaMath.Restart)</code></pre><p>Return <code>crossing &gt; 0</code> such that a state event is triggered whenever <code>crossing &gt; 0</code> changes its value.</p><p>Note, a small hysteresis is added to the crossing function during continuous integration,  in order to reduce issues during event iterations due to small numerical errors. However, at an event instant, <code>crossing &gt; 0</code> is returned without any hysteresis.</p><p><strong>Arguments</strong></p><ul><li><code>sim::ModiaMath.SimulationState</code>: (Internal) simulation state provided by simulation engine.</li><li><code>nr::Int</code>: (&gt; 0 required) Every call of <code>positive!(..)</code> must be identified by a unique value of <code>nr</code>       This value is used as index in a vector that holds the internal memory for <code>crossing &gt; 0</code>.</li><li><code>crossing::Float64</code>: Zero crossing function.</li><li><code>crossingAsString::String</code>: <code>crossing</code> as string representation. This string is used for log messages.</li><li><code>restart::ModiaMath.</code><a href="DAE.html#ModiaMath.DAE.EventRestart"><code>EventRestart</code></a>: Restart action after the <code>crossing &gt; 0</code> event occurred.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">function computeVariables!(m::Model, sim::SimulationState)
   ...
   # f = s &gt; 0 ? fMax : 0.0
   m.sPos.value = ModiaMath.positive!(sim, 1, m.s.value, &quot;s&quot;)
   m.f.value    = m.sPos.value ? m.fMax.value : 0.0
   ...
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L183-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.setNextEvent!-Tuple{ModiaMath.DAE.SimulationState,Float64}" href="#ModiaMath.DAE.setNextEvent!-Tuple{ModiaMath.DAE.SimulationState,Float64}"><code>ModiaMath.DAE.setNextEvent!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.setNextEvent!(sim, nextEventTime; integratoToEvent=true, restart = ModiaMath.Restart)</code></pre><p>At an event instant (isEvent(sim) == true) trigger the next time event. </p><p><strong>Arguments</strong></p><ul><li><code>sim::ModiaMath.SimulationState</code>: (Internal) simulation state provided by simulation engine.</li><li><code>nextEventTime::Float64</code>: Time instant of the next time event.</li><li><code>integrateToEvent::Bool</code>: If true, the integrator integrates exactly to this event. If false, the integrator might integrate beyond <code>nextEventTime</code> (so the step size of the integrator is not influenced by this event). This option is only useful, if information is inquired at the event and restart=ModiaMath.NoRestart is used. The benefit is that the integrator is  practically not influenced by this event.</li><li><code>restart::ModiaMath.</code><a href="DAE.html#ModiaMath.DAE.EventRestart"><code>EventRestart</code></a>: Restart action after the event at which <code>setNextEvent!</code> was called.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L160-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ModiaMath.DAE.setNominal!-Tuple{ModiaMath.DAE.SimulationState,Array{Float64,1}}" href="#ModiaMath.DAE.setNominal!-Tuple{ModiaMath.DAE.SimulationState,Array{Float64,1}}"><code>ModiaMath.DAE.setNominal!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ModiaMath.setNominal!(sim::ModiaMath.SimulationState, x_nominal::Vector{Float64})</code></pre><p>At initialization provide <code>x_nominal, the nominal values of the x-vector, and  store them in</code>sim`, the simulation state. These values are used to compute the absolute tolerances of the x-vector for the integrator.</p><p><strong>Example</strong></p><pre><code class="language-julia">function getModelResidues!(m::Model, t, x, derx, r, w)
   sim = m.simulationState
   if ModiaMath.isInitial(sim)
      ModiaMath.setNominal!(sim, [1.0, 1e-5, 1e8])   # if length(x)=3
   end
   ...
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/ModiaSim/ModiaMath.jl/blob/40d2d0daca9bcb28fbb11c1b3b98d44dc760ced5/src/DAE/functionsForUserModels.jl#L132-L150">source</a></section><pre><code class="language-none"></code></pre><footer><hr/><a class="previous" href="Result.html"><span class="direction">Previous</span><span class="title">Result</span></a><a class="next" href="NonlinearEquations.html"><span class="direction">Next</span><span class="title">NonlinearEquations</span></a></footer></article></body></html>
